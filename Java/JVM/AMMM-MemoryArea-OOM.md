# Java内存区域 -- 内存溢出异常（**OOM**）

> 这里的Java的内存区域指的是，**运行时数据区域**。

Java好处有很多，在我看来，java最大的好处是不用手动管理内存了。Java使用虚拟机自动管理，自动回收内存，很少会出现**内存泄漏**，**内存溢出**的问题。但是，如果虚拟机一旦出现了这些问题，如果对JVM堆内存的使用有所了解，那么排查这个问题会相对容易一些。

Java虚拟机在执行程序过程中，会把它管理的内存划分成若干个不同的**数据区域**，而且每个区域都有自己的用途。比如，方法区，虚拟机栈，本地方法栈，堆和程序计数器。

## 内存区域（Memeory Area）

![image-20200525130919709](https://gitee.com/klenkiven/Blogs/raw/master/img/AMMM-MemeoryArea-OOM-1.png)

> 如图，上面的灰色区域是**线程共享**的内存区域，白色区域是**线程私有**的内存区域。
>
> 矩形区域会有OOM的情况，可见程序计数器是唯一一个没有任何OOM情况的区域。

### 程序计数器（Program Counter ）

+ 线程私有：每条线程都需要有一个独立的程序计数器

+ 内存空间较小

+ 无OutOfMemoryError情况

+ 计数器记录内容：

  + 正在执行一个Java方法：

    计数器记录的是正在执行的**虚拟机字节码指令的地址**

  + 正在执行一个Native方法：

    计数器值为**空（Undefined）**

### Java虚拟机栈（Java Virtual Machine Stack）

+ 线程私有
+ 生命周期与线程相同
+ 抛出异常：**OutOfMemoryError**和**StackOverFlowError**

虚拟机栈描述的是一个**方法执行的内存模型**：每个方法在执行的同时会创建一个**栈帧（Stack Frame）**[^1]用于储存局部变量表，操作数栈、动态链接、方法出口等等信息。每一个方法调用直至完成的过程，就对应这个一个栈帧在虚拟机中入栈到出栈的过程。

[^1]: 栈帧是用于支持虚拟机进行**方法调用和方法执行**的数据结构，它是虚拟机运行时数据区域中的虚拟机栈（Virtual Machine Stack）的**栈元素**

现在，程序员口中常说的**栈内存（Stack）**一般是指虚拟机栈，或者说着重指的是**局部变量表**部分。局部变量表存放了编译期可知的各种基本数据类型、对象引用（reference类型[^2]）和returnAddress类型的数据[^3]。

[^2]:可能是指向对象起始地址的引用指针，也可能是一个代表对象的句柄或与此对象相关的位置
[^3]:指向一条字节码指令的地址

如果线程请求的**栈深度**大于虚拟机允许的深度，则抛出**StackOverFlowError异常**。

如果动态扩展时**无法申请到足够的内存**，则抛出**OutOfMemoryError异常**。

### 本地方法栈（Native Method Stack）

+ 本地方法栈则为虚拟机是用到的**Native方法**服务

+ 和java虚拟机栈发挥的作用十分相似，性质也基本相同
+ 有一些虚拟机比如HotSpot虚拟机直接把本地方法栈和虚拟机栈**合二为一**
+ 抛出异常：**OutOfMemoryError**和**StackOverFlowError**

### Java堆

+ 线程共享

+ **唯一目的**：存放对象实例

  >  所有的对象实例以及数组要在堆上分配

+ Java堆是垃圾收集管理的主要区域，影刺很多时候也称为**GC堆**（**Garbage Collectoin Heap**）